from django.db import models
from django.utils.translation import gettext_lazy as _
from room.models.locations import Location, Next_to
from .unit import Unit
from .room import Room
from .turn import Turn


class MoveType(models.TextChoices):
    HOLD = 'HLD', _('Hold')
    MOVE = 'MVE' , _('Move')
    SUPPORT = 'SPT', _('Support')
    CONVOY = 'CVY', _('Convoy')

# want the order to be kept for history, even if unit is destoryed later
class Order(models.Model):

    class Meta:
        verbose_name_plural = 'Orders'

    # basic information, generated by backend first
    room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name='room_oder')
    instruction = models.CharField(max_length=3,choices=MoveType.choices,default=MoveType.HOLD) # Not null
    turn = models.ForeignKey(Turn, on_delete=models.DO_NOTHING) # Not null
    unit = models.ForeignKey(Unit,on_delete=models.DO_NOTHING,related_name='target_unit') # Not null
    current_location = models.ForeignKey(Location,on_delete=models.DO_NOTHING,related_name='current_location') # Not null
    # move operation only
    target_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='target_location')
    # spt/convoy operation only
    reference_unit = models.ForeignKey(Unit,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit')
    reference_unit_current_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit_current_location')
    reference_unit_new_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit_new_location')
    
    # will check moves are valid by themselves when submitted by player
    def _valid_order_given_no_others(self) -> bool:
        if type(self.current_location) is Location and type(self.unit) is Unit and \
            self.unit.location == self.current_location:
            if self.instruction == MoveType.HOLD:
                if self.target_location is None and \
                    self.reference_unit is None and \
                    self.reference_unit_current_location is None and \
                    self.reference_unit_new_location is None and \
                    ((self.unit.can_float and (self.current_location.is_sea or self.current_location.is_coast)) or \
                    (not self.unit.can_float and (not self.current_location.is_sea or self.current_location.is_coast))):
                    return True
            elif self.instruction == MoveType.MOVE:
                if type(self.target_location) is Location and \
                    self.reference_unit is None and \
                    self.reference_unit_current_location is None and \
                    self.reference_unit_new_location is None and \
                    ((self.unit.can_float and 
                        (self.target_location.is_coast or self.target_location.is_sea) and 
                        len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.target_location)) == 1
                     ) or \
                     (not self.unit.can_float and \
                      ((self.current_location.is_coast and self.target_location.is_coast) or \
                       ((not self.target_location.is_sea or (self.target_location.is_sea and self.target_location.is_coast)) and \
                        len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.target_location)) == 1))
                    )):
                        return True
                     
            elif self.instruction == MoveType.SUPPORT:
                if self.target_location is None and \
                    type(self.reference_unit) is Unit and \
                    type(self.reference_unit_current_location) is Location and \
                    type(self.reference_unit_new_location) is Location and \
                    ((self.unit.can_float and 
                        (self.reference_unit_new_location.is_coast or self.reference_unit_new_location.is_sea)) or \
                     (not self.unit.can_float and 
                        (self.reference_unit_new_location.is_coast or not self.reference_unit_new_location.is_sea))
                     ) and \
                    len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.reference_unit_new_location)) == 1:
                    # don't need to check if reference unit's move is valid at this stage
                    # just check the spt is for a location next to current
                    return True
            elif self.instruction == MoveType.CONVOY:
                if self.target_location is None and \
                    self.unit.can_float and \
                    self.current_location.is_sea and \
                    type(self.reference_unit) is Unit and \
                    not self.reference_unit.can_float and \
                    type(self.reference_unit_current_location) is Location and \
                    type(self.reference_unit_new_location) is Location:
                    # don't need to check if reference unit's move is valid at this stage
                    return True
        return False

    def save(self, *args, **kwargs):
        # only if the order is basic possible is it saved 
        # allows us to only save orders that would be valid 
        # given no other Orders
        if not self._valid_order_given_no_others():
            return False
        else:
            # save!
            super(Order,self).save(*args, **kwargs)
            return True

    def __str__(self):
        return str(self.pk)
    
