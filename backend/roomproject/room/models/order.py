from django.db import models
from django.utils.translation import gettext_lazy as _
from room.models.locations import Location, Next_to
from room.game.unitTypes import Unit
from room.game.outcomeManager import OutcomeManager

class Turn(models.Model):
    year = models.IntegerField()
    is_autumn = models.BooleanField(default=False)
    # yes I know its dumb, but allows us to easily identify when retreats can move
    is_retreat_turn = models.BooleanField(default=False)

    def __str__(self):
        return str(self.pk)
    # set the close_time while save, automatactly add 2 hours
    def save(self, *args, **kwargs):
        #self.close_time = self.build_time + datetime.timedelta(hours=2)
        super(Turn, self).save(*args, **kwargs)


class MoveType(models.TextChoices):
    HOLD = 'HLD', _('Hold')
    MOVE = 'MVE' , _('Move')
    SUPPORT = 'SPT', _('Support')
    CONVOY = 'CVY', _('Convoy')

# want the order to be kept for history, even if unit is destoryed later
class Order(models.Model):

    class Meta:
        verbose_name_plural = 'Orders'

    # basic information, generated by backend first
    instruction = models.CharField(max_length=3,choices=MoveType.choices,default=MoveType.HOLD) # Not null
    turn = models.ForeignKey(Turn, on_delete=models.DO_NOTHING) # Not null
    target_unit = models.ForeignKey(Unit,on_delete=models.DO_NOTHING,related_name='target_unit') # Not null
    current_location = models.ForeignKey(Location,on_delete=models.DO_NOTHING,related_name='current_location') # Not null
    target_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='target_location')
    # spt/convoy operation only
    reference_unit = models.ForeignKey(Unit,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit')
    reference_unit_current_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit_current_location')
    reference_unit_new_location = models.ForeignKey(Location,blank=True,null=True,on_delete=models.DO_NOTHING,related_name='reference_unit_new_location')


    # will check moves are valid by themselves when submitted by player
    def _valid_order_given_no_others(self) -> bool:
        if type(self.current_location) is Location and type(self.target_unit) is Unit and \
            self.target_unit.location == self.current_location:
            if self.instruction == MoveType.HOLD:
                if self.target_location is None and \
                    self.reference_unit is None and \
                    self.reference_unit_current_location is None and \
                    self.reference_unit_new_location is None and \
                    ((self.target_unit.can_float and (self.current_location.is_sea or self.current_location.is_coast)) or \
                    (not self.target_unit.can_float and (not self.current_location.is_sea or self.current_location.is_coast))):
                    return True
            elif self.instruction == MoveType.MOVE:
                if type(self.target_location) is Location and \
                    self.reference_unit is None and \
                    self.reference_unit_current_location is None and \
                    self.reference_unit_new_location is None and \
                    ((self.target_unit.can_float and 
                        (self.target_location.is_coast or self.target_location.is_sea) and 
                        len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.target_location)) == 1
                     ) or \
                     (not self.target_unit.can_float and \
                      ((self.current_location.is_coast and self.target_location.is_coast) or \
                       ((not self.target_location.is_sea or (self.target_location.is_sea and self.target_location.is_coast)) and \
                        len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.target_location)) == 1))
                    )):
                        return True
                     
            elif self.instruction == MoveType.SUPPORT:
                if self.target_location is None and \
                    type(self.reference_unit) is Unit and \
                    type(self.reference_unit_current_location) is Location and \
                    type(self.reference_unit_new_location) is Location and \
                    ((self.target_unit.can_float and 
                        (self.reference_unit_new_location.is_coast or self.reference_unit_new_location.is_sea)) or \
                     (not self.target_unit.can_float and 
                        (self.reference_unit_new_location.is_coast or not self.reference_unit_new_location.is_sea))
                     ) and \
                    len(Next_to.objects.filter(location=self.current_location)\
                        .filter(next_to=self.reference_unit_new_location)) == 1:
                    # don't need to check if reference unit's move is valid at this stage
                    # just check the spt is for a location next to current
                    return True
            elif self.instruction == MoveType.CONVOY:
                if self.target_location is None and \
                    self.target_unit.can_float and \
                    self.current_location.is_sea and \
                    type(self.reference_unit) is Unit and \
                    not self.reference_unit.can_float and \
                    type(self.reference_unit_current_location) is Location and \
                    type(self.reference_unit_new_location) is Location:
                    # don't need to check if reference unit's move is valid at this stage
                    return True
        return False

    def save(self, *args, **kwargs):
        # only if the order is basic possible is it saved 
        # allows us to only save orders that would be valid 
        # given no other Orders
        if not self._valid_order_given_no_others():
            return False
        else:
            # save!
            super(Order,self).save(*args, **kwargs)
            return True

    def __str__(self):
        return str(self.pk)
    

class OutcomeType(models.TextChoices):
        MAYBE = 'MYBE', _('Order Not Evaluated')
        MARK = 'MARK', _('Order Marked for future Evaluation')
        NO_CONVOY = 'NCVY', _('Move Order has No Convoy')
        PASS = 'PASS', _('Order Passed')
        VOID = 'VOID' , _('Order Failed')
        CUT = 'CUT', _('Order Cut')
        BOUNCE = 'BNCE', _('Order Bounced with another')
        DISLODGED = 'DLGE', _('Order Unit Dislodged')
        DISRUPTED = 'DRPT', _('Convoy Order Distrupted')
        DISBAND = 'DBAN', _('Order Unit needs to Disband')

class Outcome(models.Model):
    # copy of Orders - show the orders that actually happened
    objects = OutcomeManager()
    order_reference = models.ForeignKey(Order,on_delete=models.DO_NOTHING,related_name='order_reference')
    validation = models.CharField(max_length=4,choices=OutcomeType.choices,default=OutcomeType.MAYBE) # Not null
    class Meta:
        # proxy = True
        verbose_name_plural = 'Outcomes'
        
    def __str__(self):
        return str(self.pk)
